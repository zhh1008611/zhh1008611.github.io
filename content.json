{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"2022.7.8学习笔记","slug":"2022.7.8   学习笔记","date":"2022-07-09T08:53:41.868Z","updated":"2022-07-09T08:53:42.549Z","comments":true,"path":"2022/07/09/2022.7.8   学习笔记/","link":"","permalink":"http://example.com/2022/07/09/2022.7.8%20%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"反射1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/*反射:程序运行时对逻辑进行操作1.获取Class对象的三种方式: 1.类的静态方法forName() 2.类名.class 3.对象.getClass() */public class ClassDemo &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, NoSuchFieldException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //1.类的静态方法forName() Class&lt;?&gt; aClass = Class.forName(&quot;com.xjxy.day05.Student&quot;); //2.类名.class Class&lt;Student&gt; aClass1 = com.xjxy.day05.Student.class; //3.对象.getClass() Student student = new Student(); Class&lt;? extends Student&gt; aClass2 = student.getClass(); //4.使用Class对象进行反射操作: 获取构造方法的对象, 获取成员方法的对象,获取成员变量的对象 Constructor&lt;?&gt; constructor = aClass.getConstructor(); //空参构造方法的对象 //满参构造方法的对象 Constructor&lt;?&gt; constructor1 = aClass.getConstructor(String.class, int.class); //获取成员方法的对象 //getName方法的对象 Method method = aClass.getMethod(&quot;getName&quot;); //setName方法的对象 Method method1 = aClass.getMethod(&quot;setName&quot;, String.class); Method eatMethod = aClass.getMethod(&quot;eat&quot;, String.class, String.class); //获取成员变量// Field nameField = aClass.getField(&quot;name&quot;); Field nameField = aClass.getField(&quot;age&quot;); //以上的所有方法都是获取非私有的成员,私有的成员需要使用暴力反射,其实就是换一个方法即可; /*//获取到构造方法的对象,成员方法的对象,成员变量的对象能够干什么; 调用他们对应的方法执行对应的逻辑: 1.构造方法的作用就是创建对象,所以使用构造方法的对象调用方法后产生class类对应的对象 */ //Constructor对象的用法 Object o = constructor.newInstance(); System.out.println(o); Object o1 = constructor1.newInstance(&quot;张三&quot;, 26); System.out.println(o1); //Method对象的用法 Object i = method.invoke(o); System.out.println(i); Object i1 = method1.invoke(o, &quot;王五&quot;); System.out.println(i1); //null Object i2 = eatMethod.invoke(o, &quot;汉堡&quot;, &quot;西红柿&quot;); System.out.println(i2); String name = eatMethod.getName(); System.out.println(name); //eat //Field对象的用法 String name1 = nameField.getName(); System.out.println(name1); //age nameField.set(o,34); //给o对象中的成员变量age赋值 //nameField.set(o,&quot;34&quot;); //会报运行时期异常: java.lang.IllegalArgumentException(非法参数异常) System.out.println(o); //Student&#123;name=&#x27;null&#x27;, age=34&#125; Object ageValue = nameField.get(o); System.out.println(ageValue); //34 &#125;&#125; IO流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.io.*;/*IO流: I---Input O---OutPut输入输出流: 读入写出分类: 1.流的类型: 字节流(Stream): 可以操作所有的数据(音频,视频,图画,文本,word等) InputStream, OutputStream; FileInputStream, FileOutputStream 字符流(Writer/Reader): 只能操作文本类型的数据(文本:用记事本打开能够看懂的) Reader, Writer, FileReader, FileWriter 2.流的流向分类: 输入流 输出流 */public class IODemo &#123; //抛异常 public static void main(String[] args) throws IOException &#123;// method1(); //使用字节流读取视频文件,写出到另外一个地方 // ctrl+h 查看一个类的子类或者接口的实现类 //创建字节输入流对象/* InputStream inputStream = new FileInputStream(&quot;E:\\\\aaaa\\\\meeting_05.mp4&quot;); //创建字节输出流对象 OutputStream outputStream = new FileOutputStream(&quot;D:\\\\abc.mp4&quot;); //读数据和写数据,为了提高效率,我们创建一个缓存区 byte[] bys = new byte[1024 * 8]; // int len = -1; while ((len = inputStream.read(bys)) != -1) &#123; outputStream.write(bys, 0, len); &#125; //关闭流对象: IO操作文件是占用系统资源,如果不关闭会一直占用 outputStream.close(); inputStream.close();*/ method2(); &#125; //ctrl + alt + t 快速捕获异常 //io流读写文件,使用try...catch处理异常 private static void method1() &#123; InputStream inputStream = null; OutputStream outputStream = null; try &#123; //使用字节流读取视频文件,写出到另外一个地方 // ctrl+h 查看一个类的子类或者接口的实现类 //创建字节输入流对象 inputStream = new FileInputStream(&quot;E:\\\\aaaa\\\\meeting_05.mp4&quot;); //创建字节输出流对象 outputStream = new FileOutputStream(&quot;D:\\\\abc.mp4&quot;); //读数据和写数据,为了提高效率,我们创建一个缓存区 byte[] bys = new byte[1024 * 8]; // int len = -1; while ((len = inputStream.read(bys)) != -1) &#123; outputStream.write(bys, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //无论代码是否发生一次,finally中的代码一定会被执行到 //关闭流对象: IO操作文件是占用系统资源,如果不关闭会一直占用 if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //字符流读写文件 public static void method2() &#123; Reader reader = null; Writer writer = null; try &#123; //1.创建输入流对象 reader = new FileReader(&quot;D:\\\\code\\\\xjxy_workspase\\\\xjxy_javase\\\\JavaseProject_1\\\\src\\\\com\\\\xjxy\\\\day02\\\\Demo1.java&quot;); //2.创建输出流对象 writer = new FileWriter(&quot;d:\\\\Demo1.java&quot;); //3.创建缓冲区,提高读写效率 char[] chs = new char[1024 * 8]; int len = -1; //4.循环读写操作 while ((len = reader.read(chs)) != -1) &#123; writer.write(chs, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //5.关闭流对象释放资源 if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 类的调用12345678/*A类(UserServlet) :接受数据,调用B类中的方法,并将方法的返回值返回B类(UserService) :处理业务逻辑C类(UserDao) :主要的功能实现这三个类各司其职 */public class Test &#123;&#125; UserDao类12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class UserDao &#123; //定义一个方法获取三个数中的最大值 public int getMax(int a, int b, int c) &#123; //定义一个变量用于存储最大值 int result; if (a &gt; b) &#123; if (a &gt; c) &#123; result = a; &#125; else &#123; //c&gt;=a result = c; &#125; &#125; else &#123; //b&gt;=a if (b &gt; c) &#123; result = b; &#125; else &#123; //c&gt;=b result = c; &#125; &#125; return result; &#125; public int findIndex(int[] arr, int word) &#123; //二分查找的前提是数组必须有序 int index = Arrays.binarySearch(arr, word); return index; &#125;&#125; UserService类123456789101112131415161718192021222324// B调用了C中的方法public class UserService &#123; //处理业务逻辑(数据类型的转换) //获取三个数字字符串中的数字最大的那个 // &quot;23&quot;,&quot;12&quot;,&quot;2&quot; public String getMax(String x, String y, String z) &#123; //数据类型转换 int a = Integer.parseInt(x); int b = Integer.parseInt(y); int c = Integer.parseInt(z); //创建C的对象 UserDao userDao = new UserDao(); int max = userDao.getMax(a, b, c); //int--String return max + &quot;&quot;; &#125; public int findIndex(int[] arr, int word) &#123; UserDao userDao = new UserDao(); int index = userDao.findIndex(arr,word); return index; &#125;&#125; UserServlet类12345678910111213141516171819202122//A调用Bpublic class UserServlet &#123; public static void main(String[] args) &#123; String aa=&quot;230&quot;; String bb=&quot;33&quot;; String cc=&quot;13&quot;; UserService userService = new UserService(); String max = userService.getMax(aa, bb, cc); System.out.println(max); //调用B类中的一个方法,传入int数组和一个int数字,获取该数字在数组中的索引 //int[] arr = &#123;11,55,77,44,33,13&#125;; int[] arr = &#123;1,4,7,9,11,22,33,44,55,66&#125;; int word = 33; UserService service = new UserService(); //先写方法的调用，后使用快捷键生成方法的定义 // alt + enter int index = service.findIndex(arr,word); System.out.println(index); &#125;&#125;","categories":[],"tags":[]},{"title":"Eclipse中的快捷键","slug":"Eclipse中的快捷键","date":"2022-07-08T01:19:52.295Z","updated":"2022-07-08T01:19:52.464Z","comments":true,"path":"2022/07/08/Eclipse中的快捷键/","link":"","permalink":"http://example.com/2022/07/08/Eclipse%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Eclipse中的快捷键: * 1.补全代码的声明:Alt + / * 2.快速修复:Ctrl + 1 * 3.批量导包:Ctrl + Shift + o * 4.使用单行注释:Ctrl + / * 5.使用多行注释:Ctrl + Shift + / * 6.取消多行注释:Ctrl + Shift + \\ * 7.复制指定行的代码:Ctrl + Alt + down 或Ctrl + Alt + up//上下键 * 8.删除指定行代码:Ctrl + d * 9.上下移动代码:Alt + up 或 Alt + down * 10.切换到下一行代码空位:Shift + 回车 * 11.切换到上一行代码空位:Ctrl + Shift + 回车 * 12.查看源码:Ctrl + 鼠标指定的结构 或 Ctrl + Shift + t * 13.退回到前一个编辑的页面:Alt + left * 14.进入到下一个编辑页面:Alt + right * 15.光标选择指定的类,查看继承树的结构:Ctrl + t * 16.复制代码:Ctrl + c * 17.撤回代码:Ctrl + z * 18.反撤回代码:Ctrl + y * 19.剪切:Ctrl + x * 20:粘贴:Ctrl + v * 21.保存:Ctrl + s * 22.全选:Ctrl + a * 23.格式化代码:Ctrl + Shift + f * 24.选中数行整体往后移：Tab * 25.选中数行整体往前移：Shift + Tab * 26.在当前类中,显示类结构,并支持搜索指定的方法、属性等：Ctrl + o * 27.批量修改指定的变量名、方法名、类名等：Alt + Shift + r * 28.选中结构中的大小写的切换:变成大写:Ctrl + Shift + x * 29.选中结构中的大小写的切换:变成小写:Ctrl + Shift + y * 30.调用生成getter/setter/构造器等结构:Alt + Shift +s * 31.显示当前选择资源(工程 or文件)的属性:Ctrl + enter * 32.快速查找:参照选择中的Word快速定位到下一个:Ctrl + k * 33.关闭当前窗口:Ctrl + w * 34.关闭所有窗口:Ctrl + Shift + W * 35.查看指定结构使用过的地方:Ctrl + Alt + g * 36.查找与替换:Ctrl + f * 37.最大化当前的View:Ctrl + m * 38.直接定位到当前行的首行:Home * 39.直接定位到当前行的末尾:End","categories":[],"tags":[]},{"title":"2022.7.7 学习笔记","slug":"2022.7.7   学习笔记","date":"2022-07-07T03:58:05.288Z","updated":"2022-07-07T10:43:31.197Z","comments":true,"path":"2022/07/07/2022.7.7   学习笔记/","link":"","permalink":"http://example.com/2022/07/07/2022.7.7%20%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"2022.7.7 学习笔记 String 方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.Arrays;/* 1.String 1.很多重载的构造方法最常用String str1 = &quot;abcd&quot;; 2.常用方法: getBytes():将字符串转换为字节数 length()获取字符个数的方法 substring():截取字符串：用变量接收；字符串是常量，在初始化完毕后就不再发生变化 equals():比较两个字符串是否相等 */public class Day_4 &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = &quot;abcdfg&quot;; //ctrl+p:查看当前方法的参数形式 //String str2 = new String(); byte[] bytes = str.getBytes(); //ctrl+alt+v:快速生成局部变量 //ctrl+alt+f:快速生成成员变量 //alt+enter:拍错建 //常见的编码字符集:utf-8，gbk,iso8859-1 byte[] bys1 = str.getBytes(&quot;utf-8&quot;); byte[] bys2 = str.getBytes(Charset.forName(&quot;utf-8&quot;)); //打印数组 1.for循环 2.Arrays方法 System.out.println(Arrays.toString(bytes)); System.out.println(Arrays.toString(bys1)); System.out.println(Arrays.toString(bys2)); int length = str.length(); if (str!=null &amp;&amp; str.length()&gt;0) &#123; // str = &quot;abcdfg&quot; str = &quot;&quot;; System.out.println(&quot;字符串不为空&quot;); &#125; if (str == null || str.length() == 0) &#123; //str = null; str = &quot;&quot;; System.out.println(&quot;字符串为空&quot;); &#125; String sub1 = str.substring(2); System.out.println(sub1); //字符串是常量，在初始化完毕后就不再发生变化 //boolean a = str.equals(&quot;abcdfg&quot;) boolean a2 = &quot;abcdfg&quot;.equals(str);//推荐：可以避免空指针 System.out.println(a2); /* equals和 == 的区别 equals是方法，只能比较对象调用，只能比较引用数据类型 ==是运算符号：既可以比较引用数据类型（对象），也可以比较基本数据类型（常量） 当比较引用数据类型是比较地址值 当比较基本数据类型是比较具体的值 */ String str2 = new String(&quot;123456&quot;); System.out.println(str.equals(str2)); System.out.println(str == str2); int aa = 23,bb = 32; System.out.println(aa == bb); //ctrl+alt+l /* *基本数据类型：4类8种 * 整数型：byte short int long * 浮点型:float double * 字符型:char * 布尔型:boolean *引用数据类型：类，数组，接口，枚举 */ str = &quot; dsad dsadsa dsad &quot;; String t = str.trim(); System.out.println(&quot;-&quot;+t+&quot;-&quot;); /* * 包装类与字符串的相互转换 * 包装类：基本类型对应类 * * 基本类型 包类型 * byte Byte * short Short * int Integer * long Long * char Character * float Float * double Double * boolean Boolean */ /* * 基本类型借助包装类与字符串的相互转换 * int-----String * 1.给int拼 &quot;&quot; * 2.使用：Integer.toString(cc); * 3.使用：String.valueOf(cc); * 4.先把int赋值给它的包装类的对象：Integer i = cc;再使用String s2 = i.toString(); * * String---int * 1.int i1 = Integer.parseInt(str3); * 2.先Integer integer = Integer.valueOf(str3);再int i2 = integer; * 3.先Integer integer1 = new Integer(str3);再int i3 = integer1; */ int cc = 90; String c = cc + &quot;&quot;; Integer i = cc; String s2 = i.toString(); String s = Integer.toString(cc); String s1 = String.valueOf(cc); System.out.println(&quot;----------------------------&quot;); String str3 = &quot;123456789&quot;; int i1 = Integer.parseInt(str3); Integer integer = Integer.valueOf(str3); int i2 = integer; Integer integer1 = new Integer(str3); int i3 = integer1; &#125;&#125; list列表：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.ArrayList;import java.util.Iterator;import java.util.List;/* * 集合：长度可变，存储引用数据的容器 * 泛型：限制集合存储同一种类型的数据： * 1.将运行时期异常提亲到编译期 * 集合： * 如何存:调用add方法 * 如何取 * * List集合:存取有序，可重复 * ArrayList(最常用) * LinkedList * Vector */public class Day_4_list &#123; public static void main(String[] args) &#123; //多态形式创建对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); boolean a =list.add(&quot;a&quot;); list.add(&quot;b&quot;); System.out.println(a); System.out.println(list); /* * 集合遍历 * 1.普通for循环 * 2.增强for循环 * 3.迭代器 */ for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; for (String string : list) &#123; System.out.println(string); &#125; Iterator&lt;String&gt; inIterator = list.iterator(); while (inIterator.hasNext()) &#123; String st = inIterator.next(); System.out.println(st); &#125; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(12); Integer integer = Integer.valueOf(22); list1.add(integer); System.out.println(list1); List list2 = new ArrayList&lt;&gt;(); list2.add(&quot;aaaaaaa&quot;); list2.add(&quot;bbbbb&quot;); list2.addAll(list1); System.out.println(list2); list.clear(); System.out.println(list); System.out.println(list.size()); //如果集合中没有元素，isEmpty返回true boolean e = list.isEmpty(); System.out.println(e); &#125;&#125; set列表：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.Set;/* * set集合：存取无需，元素唯一 * HashSet（常用） * Treeset * LinkedHashSet *//*Collection 接口 * list：子接口 * set：子接口 * */public class Day_4_set &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet(); set.add(&quot;a&quot;); set.add(&quot;a&quot;); set.add(&quot;dd&quot;); set.add(&quot;e&quot;); set.add(&quot;ff&quot;); set.add(&quot;e&quot;); System.out.println(set); Collection&lt;String&gt; collection = new ArrayList(); collection.add(&quot;arraylist&quot;); Collection&lt;String&gt; collection1 = new HashSet(); collection1.add(&quot;hashSet&quot;); set.addAll(collection); set.addAll(collection1); System.out.println(set); //遍历 /* * 1.增强for循环 * 2.迭代器 */ for (String s : set) &#123; System.out.println(s); &#125; Iterator&lt;String&gt; iterator = set.iterator(); while (iterator.hasNext()) &#123; String st = (String) iterator.next(); System.out.println(st); &#125; &#125;&#125; collection重载方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*集合体系中有两个重载的方法 * toArray() * toArray(T[]) * 相同点：可将集合转换为数组 * 不同点：空参转换后得到Object[]；有参转换后的到泛型参数避免了强制转换 * * 数组转集合 * Array.asList()可以将数组转换成list数组 */import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;public class collectionDemo &#123; public static void main(String[] args) &#123; //ctrl+alt+m 将选中的代码封装成方法 //toArrayDemo2(); //toArrayDemo1(); int[] arr = &#123;12,13,14,15&#125;; //数组只有一个length属性：当然也能调用Object中的方法 //String s = Arrays.toString(arr); //System.out.println(s); System.out.println(Arrays.toString(arr)); /* *public static &lt;T&gt; List&lt;T&gt;(T... a): *形式参数格式：数据类型... 变量名 该参数称为可变参数；参数数量不固定，根据实际参数的数量决定 *注意：可变参数可以当作数组处理 */ String[] array = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;&#125;; List&lt;String&gt; list = Arrays.asList(array); System.out.println(list); &#125; private static void toArrayDemo2() &#123; Collection&lt;String&gt; collection = new ArrayList(); collection.add(&quot;a&quot;); collection.add(&quot;a&quot;); collection.add(&quot;b&quot;); collection.add(&quot;c&quot;); collection.add(&quot;b&quot;); collection.add(&quot;d&quot;); collection.add(&quot;e&quot;); System.out.println(collection); Object[] objects = collection.toArray(); System.out.println(Arrays.toString(objects)); for (Object object : objects) &#123; System.out.println(object); &#125; &#125; private static void toArrayDemo1() &#123; Collection&lt;Integer&gt; collection1 = new HashSet&lt;&gt;(); collection1.add(22); collection1.add(33); collection1.add(44); collection1.add(22); collection1.add(33); collection1.add(22); System.out.println(collection1); Integer[] integers = collection1.toArray(new Integer[0] ); System.out.println(Arrays.toString(integers)); for (Integer integer : integers) &#123; System.out.println(integer); &#125; &#125; &#125; 异常1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileInputStream;import java.io.FileNotFoundException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* * Throwable:异常的顶层父类 * Error：错误 * Exception：异常 * 异常有两大类：直接或间接继承RuntimeException的异常，称运行时异常 * 直接或间接继承Exception，称编译时异常 * 异常的处理 * 编译时异常：程序报红，所以必须处理才能运行 * 运行时异常：可以不处理也可以主动处理 * 处理方式：alt+enter 然后二选一 * 1.try...catch * 2.throws * * */public class Day_4_EceptionDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileInputStream fileInputStream = new FileInputStream(&quot;&quot;); String timStr = &quot;2022-07-07 17:32:33&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = null; try &#123; date = (Date) sdf.parse(timStr); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(date); &#125; &#125; Map接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;/* * Map接口：双列集合，存的是元素的键值对 * HashMap(常用)：建唯一（建相同，值覆盖） * put：存数据 * 遍历：取数据 * 1.获取键值对集合，使用键值对对象获取key，获取value * 2.获取所有key的集合， * TreeMap * */public class Day_4_MapDemo &#123; public static void main(String[] args) &#123; //多态创建对象 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //&#123;&quot;yq001&quot;:&quot;张三&quot;&#125; String v = map.put(&quot;yq001&quot;,&quot;张三&quot;); System.out.println(v); String v2 = map.put(&quot;yq002&quot;, &quot;里斯&quot;); //&#123;&quot;yq001&quot;:&quot;张三&quot;,&quot;yq002&quot;: &quot;里斯&quot;&#125; System.out.println(v2); String v3 = map.put(&quot;yq003&quot;, &quot;王五&quot;); System.out.println(v3); //遍历// Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();// for (Map.Entry&lt;String,String&gt; entry : map.entrySet()) &#123;// String key = entry.getKey();// String value = entry.getValue();// System.out.println(key+&quot;---------&quot;+value);// &#125;// // Set&lt;String&gt; keySet = map.keySet();// for (String key : keySet) &#123;// String value = map.get(key);// System.out.println(key+&quot;========&quot;+value);// &#125;// System.out.println(map); tosStringDemo(map); &#125; public static String tosStringDemo(Map map)&#123; System.out.println(&quot;&#123;&quot;); Set&lt;Map.Entry&gt; set = map.entrySet(); int i = 0; for (Entry entry : set) &#123; Object key = entry.getKey(); Object value = entry.getValue(); if (i == set.size()-1) &#123; System.out.println(key+&quot;=&quot;+value+&quot;&#125;&quot;); break; &#125;else &#123; System.out.println(key+&quot;=&quot;+value+&quot;, &quot;); i++; &#125; &#125; return null; &#125; &#125; 线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*创建线程的最常用的两种方式 1.继承Thread,主动重写run方法,在run方法体中写业务逻辑; 在测试类中创建Thread子类对象调用start方法; 2.实现Runable接口,(该实现类是一个任务类,需要让线程执行任务),创建实现类对象作为Thread的有参构造的形式参数, 使用Thread对象的start方法启动线程 *//*1.实现Runnable可以写成匿名内部类的方式2.实现Runnable可以写成lamdb表达式 */public class Day_4_ThreadDemo &#123; public static void main(String[] args) &#123;// method1();// method2(); /* 匿名内部类的格式: new 类名/接口名()&#123; 重写的方法; &#125;; */ demo3(); demo2(); demo1(); &#125; //匿名内部类的写法3 private static void demo3() &#123; Runnable subRunnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;; Thread thread = new Thread(subRunnable); thread.setName(&quot;线程1&quot;); thread.start(); new Thread(subRunnable).start(); new Thread(subRunnable).start(); new Thread(subRunnable).start(); &#125; //匿名内部类的写法2 private static void demo2() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;最简化的写法&quot;); &#125; &#125;).start(); &#125; //匿名内部类的写法1 private static void demo1() &#123; Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;最简化的写法&quot;); &#125; &#125;); thread1.setName(&quot;线程11111&quot;); thread1.start(); &#125; private static void method2() &#123; Runnable subRunnable = new SubRunnable(); Thread thread = new Thread(subRunnable); thread.setName(&quot;线程1&quot;); Thread thread2 = new Thread(subRunnable); thread2.setName(&quot;线程2&quot;); thread.start(); thread2.start(); &#125; private static void method1() &#123; //创建子线程的对象 SubThread subThread = new SubThread(); subThread.setName(&quot;线程一&quot;); //启动线程 subThread.start(); //创建子线程的对象 SubThread subThread2 = new SubThread(); subThread2.setName(&quot;线程二&quot;); //启动线程 subThread2.start(); &#125; &#125; 接口123456789101112public class SubRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;public class SubThread extends Thread &#123; public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 注：文中所有快捷方式均适用于Java IDEA 其余编译软件是否支持还有待考察。","categories":[],"tags":[]},{"title":"","slug":"说明","date":"2022-07-06T14:06:12.541Z","updated":"2022-07-06T14:06:13.003Z","comments":true,"path":"2022/07/06/说明/","link":"","permalink":"http://example.com/2022/07/06/%E8%AF%B4%E6%98%8E/","excerpt":"","text":"说明：2022年1月1日至今没有更新博客 因为学习和其他一些因素导致不能继续更新博客，2022.7.7开始将进行Java的学习，同时将开始继续更新博客","categories":[],"tags":[]},{"title":"我的博客介绍","slug":"我的博客介绍","date":"2022-01-23T07:47:25.972Z","updated":"2022-01-26T13:13:14.128Z","comments":true,"path":"2022/01/23/我的博客介绍/","link":"","permalink":"http://example.com/2022/01/23/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"我的博客进行了一次基础的美化","categories":[],"tags":[]},{"title":"","slug":"新人报道","date":"2021-12-28T10:30:00.149Z","updated":"2021-12-29T11:30:55.502Z","comments":true,"path":"2021/12/28/新人报道/","link":"","permalink":"http://example.com/2021/12/28/%E6%96%B0%E4%BA%BA%E6%8A%A5%E9%81%93/","excerpt":"","text":"title: 新人报道 博客建立日记2021.12.27 我开始建立自己的私人博客，通过观看哔哩哔哩UP主CodeSheep的教学视频完成了hexo博客的前期建立，但由于该视频发布过早，GitHub进行更新导致博客无法部署到GitHub上 2021.12.28 通过观看哔哩哔哩UP主视频搬运崽啊的视频，完成了hexo博客部署到GitHub，至此我的hexo博客初建完成","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-27T18:49:00.721Z","updated":"2021-12-27T18:49:00.721Z","comments":true,"path":"2021/12/28/hello-world/","link":"","permalink":"http://example.com/2021/12/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}